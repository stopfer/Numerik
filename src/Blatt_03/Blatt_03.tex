%Schriftgröße, Layout, Papierformat, Art des Dokumentes
\documentclass[10pt,oneside,a4paper]{scrartcl}

%Einstellungen der Seitenränder
\usepackage[left=3cm,right=4cm,top=3cm,bottom=3cm,includeheadfoot]{geometry}

%neue Rechtschreibung
\usepackage{ngerman}

%Umlaute ermöglichen
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

%Kopf- und Fußzeile
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}

%ermöglicht Text ein- / auszublenden
\usepackage{comment}

%\includecomment{Vortrag}
\excludecomment{Vortrag}

%to do
\usepackage{todonotes}

%Mathesachen
\usepackage{amsmath}
\usepackage{amssymb}

%Zeichnen
\usepackage{tikz}

%ermöglicht, Abbildung nicht zu benennen
\usepackage{caption}

%Linie oben
\renewcommand{\headrulewidth}{0.5pt}

%Linie unten
\renewcommand{\footrulewidth}{0.5pt}

%keine Einrückung am Absatzanfang
\parindent=0pt

%for captionof{figure}{"caption"}
\usepackage{caption}

%%for c++ syntax highlights
\usepackage{listings} 
\usepackage{verbatim}

%%for tikz
\usepackage{tikz,times}
\usetikzlibrary{mindmap,trees,backgrounds,arrows}
\tikzstyle{every picture}+=[remember picture]
\everymath{\displaystyle}

%%some colors
\definecolor{myblue}{RGB}{80,80,160}
\definecolor{mygreen}{RGB}{80,160,80}
\definecolor{darkblue}{rgb}{0,0,.6}
\definecolor{darkred}{rgb}{.6,0,0}
\definecolor{darkgreen}{rgb}{0,.5,0}
\definecolor{red}{rgb}{.98,0,0}
\definecolor{shellbackgroundcolor}{rgb}{1,1,1}
\definecolor{shellfontcolor}{rgb}{0,0,0}
\definecolor{shadethmcolor}{rgb}{1,1,1}
\definecolor{bg}{rgb}{0.975,0.98,1}
\definecolor{shaderulecolor}{rgb}{0.40,0.45,0.40}%
\definecolor{mywhite}{rgb}{1,1,1}
\definecolor{myblack}{rgb}{0,0,0}

%%c++ newenvironment
\lstset{%
  language=C++,
  basicstyle= \fontsize{9}{1} \ttfamily,
  commentstyle=\itshape\color{darkgreen},
  keywordstyle=\bfseries\color{darkblue},
  stringstyle=\color{darkred},
  showspaces=false,
  showtabs=false,
  columns=fixed,
  %numbers=left,
  tabsize=3,
  %frame=trBL,
  backgroundcolor=\color{white},
  rulecolor=\color{shaderulecolor},
  %frame=single ,
  numberstyle=\tiny,
  breaklines=true,
  showstringspaces=false,
  xleftmargin=0cm,
  nolol=true,
  captionpos=b,
  morekeywords={Vector,VectorVector,EE,DglE1} }

\lstnewenvironment{cppcode}[1][]%
{
%\begin{center}
\minipage{\textwidth}
\renewcommand\lstlistingname{C++ Code Snipped}%
\renewcommand\lstlistlistingname{c++ Code Snippeds}%
\lstset{%
  language=C++,
  basicstyle= \fontsize{9}{9} \ttfamily,
  commentstyle=\bfseries\itshape\color{darkgreen},
  keywordstyle=\bfseries\color{darkblue},
  stringstyle=\color{darkred},
  showspaces=false,
  showtabs=false,
  columns=fixed,
  %numbers=left,
  tabsize=3,
  caption=#1,
  frame=tb,
  backgroundcolor=\color{bg},
  rulecolor=\color{black},
  %frame=single ,
  %numberstyle=\tiny,
  breaklines=true,
  showstringspaces=false,
  xleftmargin=0cm,
  nolol=true,
  captionpos=b,
  morekeywords={VectorVector,DglE1,EE,Model,Solver} }
}
{
\endminipage
%\end{center}
}

\newcommand{\parspace}{ $\;$\\  \\ }

\newcommand{\code}[1]{\lstinline| #1 |}

\begin{document}
	%\title{Strukturen großer Netzwerke}
	%\author{Kathrin Ronellenfitsch}
	%\maketitle

	\begin{center}
		\huge % Schriftgröße einstellen
		\bfseries % Fettdruck einschalten
		\sffamily % Serifenlose Schrift
		Numerik Blatt 1\\[1em]
		\normalsize
		Kathrin Ronellenfitsch, Thorsten Beier, Christopher Pommrenke
	\end{center}

	
	\section*{Aufgabe 1}

    	\subsection*{1.1}


	\subsection*{1.2}


	\subsection*{1.3}

	\begin{equation*}
		F(h;t,x) = \sum_{i=1}^{s} b_ik_i(h;t,x)
	\end{equation*}
	\begin{equation*}
		k_i = f(t_{n-1} + c_ih_n. y_{n-1} + h \sum_{j=1}^{s} a_{ij}k_j)
	\end{equation*}
	Es gilt: $ F(0;t,x) = \sum_{i=1}^{s} b_if(t_{n-1},y_{n-1})$
	\begin{align*}
		& \quad \text{Sei }  \sum_{i=1}^{s} b_i = 1  \\
		& \Leftrightarrow \lim_{h \to 0} F(h;t,x) = f(t_{n-1},y_{n-1}) \\
		& \Leftrightarrow \lim_{h \to 0} ||\tau_n^h|| = \lim_{h \to 0} ||h_n^{-1}(u(t_{n})-u(t_{n-1})) - F(h;t,x)|| \\
		& \overset{h_n = t_n - t_{n-1}}{=}  \lim_{h \to 0} \left| \left| \underbrace {\frac{u(t_{n})-u(t_{n-1})}{t_n - t_{n-1}}}_{\to u'(t_{n-1})\text{ für } h \to 0} - F(h;t,x)\right|\right| = || u'(t_{n-1}) -  f(t_{n-1},y_{n-1}) ||= || u'(t_{n-1}) -  u'(t_{n-1}) ||= 0
    \end{align*}

\newpage
    \section*{Aufgabe 3}

    Verwendete Headder:
        
\begin{cppcode}
#include <iostream>

#include "hdnum.hh"
#include "initial_value_problem.h"
#include "expliciteuler.hh"          //from examplecode of hdnum
#include "heuns_method.h"
    \end{cppcode}
    
    Hilfsfunktion um bestmoegliche Annaeherung an einen vorgegebenen Zeitschritt
    zu bestimmen:
    
    \begin{cppcode}
// y - eps < x < y + eps ?
bool inRange(const double x, const double y, const double eps) {
    if(x > y - eps) {
        if (x < y + eps) {
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
}
    \end{cppcode}
    
    Hilfsfunktion um die Konvergenzordnung zu berechnen:
    
    \begin{cppcode}
template <class T>
T computeConvergenceOrder(const T x1, const T x2, const T xExact) {
  const T error1 = x1 - xExact;
  const T error2 = x2 - xExact;
  return log(fabs(error1 / error2)) / log(2.0);
}
    \end{cppcode}
    
    Hilfsfunktion um den Durchschnittswert eines Vectors zu berechnen:
    
    \begin{cppcode}
template <class VECTOR>
typename VECTOR::value_type computeAverage(const VECTOR& vec) {
  typename VECTOR::value_type average = 0.0;
  for(size_t i = 0; i < vec.size(); i++) {
    average += vec.at(i);
  }
  average /= vec.size();
  return average;
}
    \end{cppcode}

    verwendete AWA:
    
    \begin{cppcode}
/** @brief Example class for a differential equation model

    The model is

    u'(t) = lambda*t*u^(-1)(t)

    \tparam T a type representing time values
    \tparam N a type representing states and f-values
*/
template<class T, class N=T>
class InitialValueProblem {
private:
  const N lambda;
  const N u0;
  const N t0;

public:
  /** \brief export size_type */
  typedef std::size_t size_type;

  /** \brief export time_type */
  typedef T time_type;

  /** \brief export number_type */
  typedef N number_type;

  //! constructor stores parameter lambda
  InitialValueProblem (const N& lambda_, const N& u0_, const N& t0_)
    : lambda(lambda_), u0(u0_), t0(t0_)
  {}

  //! return number of componentes for the model
  std::size_t size () const
  {
    return 1;
  }

  //! set initial state including time value
  void initialize (T& t0, hdnum::Vector<N>& x0) const
  {
    t0 = this->t0;
    x0[0] = u0;
  }

  //! model evaluation
  void f (const T& t, const hdnum::Vector<N>& x, hdnum::Vector<N>& result) const
  {
    result[0] = (lambda*t)/x[0];
  }

  //! jacobian evaluation needed for implicit solvers
  void f_x (const T& t, const hdnum::Vector<N>& x, hdnum::DenseMatrix<N>& result) const
  {
    throw std::string("Jacobian evaluation not implemented!");
  }
};    
    \end{cppcode}
        
    main():
    
    \begin{cppcode}
int main() {
  typedef double Number;                    // define a number type

  const Number t0             = -0.5;       // initial time
        Number tStep          = 0.00001;    // delta t
  const Number tIntermediate  = 0.0;        // state at this time will be printed on console
  const Number uIntermediate  = sqrt(1 - (tIntermediate * tIntermediate)); // exact state at tIntermediate
  const Number tMax           = 1.0;        // end time
  const Number u0             = 0.75;       // initial state
  const Number lambda         = -1.0;     // factor for the model

  const size_t iStart         = 3;
  const size_t iEnd           = 8;

  hdnum::Vector<Number> statesIntermediate;     // store intermediate state values
  hdnum::Vector<Number> statesIntermediate2;     // store intermediate state values
  for(size_t i = iStart; i <= iEnd; i++) {
    tStep = pow(2.0, -static_cast<double>(i));
    typedef InitialValueProblem<Number> Model;  // Model type
    Model model(lambda, u0, t0);                // instantiate model

    typedef ExplicitEuler<Model> Solver;        // Solver type
    typedef HeunsMethod<Model> Solver2;        // Solver type
    Solver solver(model);                       // instantiate solver
    solver.set_dt(tStep);                       // set initial time step

    Solver2 heuns_method(model);
    heuns_method.set_dt(tStep);

    hdnum::Vector<Number> times;                // store time values here
    hdnum::Vector<hdnum::Vector<Number> > states;   // store states here
    times.push_back(solver.get_time());       // initial time
    states.push_back(solver.get_state());       // initial state

    hdnum::Vector<Number> times2;                // store time values here
    hdnum::Vector<hdnum::Vector<Number> > states2;   // store states here
    times2.push_back(heuns_method.get_time());       // initial time
    states2.push_back(heuns_method.get_state());       // initial state

    while (solver.get_time() < tMax)         // the time loop
    {
      solver.step();                          // advance model by one time step
      heuns_method.step();
      times.push_back(solver.get_time());       // save time
      states.push_back(solver.get_state());     // and state
      times2.push_back(heuns_method.get_time());       // save time
      states2.push_back(heuns_method.get_state());     // and state
      if(inRange(tIntermediate, solver.get_time(), tStep/2.0)) {    // print state at intermediate time
        //std::cout << "State at time t(delta t = " << tStep << ") = " << solver.get_time() << ": " << solver.get_state() << std::endl;
        statesIntermediate.push_back(solver.get_state().at(0));
        statesIntermediate2.push_back(heuns_method.get_state().at(0));
      }
    }
    if(i == iEnd) {
      gnuplot("exercise_03_3_euler.dat",times,states);    // output model result
      gnuplot("exercise_03_3_heun.dat",times2,states2);    // output model result
    }
  }

  hdnum::Vector<Number> convergenceOrders;     // store computed convergence orders
  hdnum::Vector<Number> convergenceOrders2;     // store computed convergence orders
  for(size_t i = 0; i < iEnd - iStart; i++) {
    convergenceOrders.push_back(computeConvergenceOrder(statesIntermediate.at(i), statesIntermediate.at(i + 1), uIntermediate));
    std::cout << "euler convergence order for h = " << pow(2.0, -static_cast<double>(i + iStart)) << " : " << convergenceOrders.back() << std::endl;
    convergenceOrders2.push_back(computeConvergenceOrder(statesIntermediate2.at(i), statesIntermediate2.at(i + 1), uIntermediate));
    std::cout << "heun convergence order for h = " << pow(2.0, -static_cast<double>(i + iStart)) << " : " << convergenceOrders2.back() << std::endl;
  }

  Number averageConvergenceOrder = computeAverage(convergenceOrders);
  std::cout << "euler average convergence order: " << averageConvergenceOrder << std::endl;
  Number averageConvergenceOrder2 = computeAverage(convergenceOrders2);
  std::cout << "heun average convergence order: " << averageConvergenceOrder2 << std::endl;

  return 0;
}
    \end{cppcode}
    
    \subsection*{Berechnete Werte:}
    
    \begin{center}
        \begin{tabular}[htbp]{c|c|c}
        h & Konvergenzordnung(euler) & Konvergenzordnung(heun) \\
        \hline
        $2^{-5}$ & $-0.432682$ & $-0.000760772$\\
        $2^{-6}$ & $-0.171833$ & $-9.41009e-05$\\
        $2^{-7}$ & $-0.0779924$ & $-1.16236e-05$\\
        $2^{-8}$ & $-0.0372864$ & $-1.44197e-06$\\
        $2^{-9}$ & $-0.0182444$ & $-1.79491e-07$\\
        \hline
        \hline
        $\varnothing$ & -0.147608 & -0.000173624
        \end{tabular}
    \end{center}
\end{document}
