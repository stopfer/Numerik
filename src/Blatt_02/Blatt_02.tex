%Schriftgröße, Layout, Papierformat, Art des Dokumentes
\documentclass[10pt,oneside,a4paper]{scrartcl}

%Einstellungen der Seitenränder
\usepackage[left=3cm,right=4cm,top=3cm,bottom=3cm,includeheadfoot]{geometry}

%neue Rechtschreibung
\usepackage{ngerman}

%Umlaute ermöglichen
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

%Kopf- und Fußzeile
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}

%ermöglicht Text ein- / auszublenden
\usepackage{comment}

%\includecomment{Vortrag}
\excludecomment{Vortrag}

%to do
\usepackage{todonotes}

%Mathesachen
\usepackage{amsmath}
\usepackage{amssymb}

%Zeichnen
\usepackage{tikz}

%ermöglicht, Abbildung nicht zu benennen
\usepackage{caption}

%Linie oben
\renewcommand{\headrulewidth}{0.5pt}

%Linie unten
\renewcommand{\footrulewidth}{0.5pt}

%keine Einrückung am Absatzanfang
\parindent=0pt

%for captionof{figure}{"caption"}
\usepackage{caption}

%%for c++ syntax highlights
\usepackage{listings} 
\usepackage{verbatim}

%%for tikz
\usepackage{tikz,times}
\usetikzlibrary{mindmap,trees,backgrounds,arrows}
\tikzstyle{every picture}+=[remember picture]
\everymath{\displaystyle}

%%some colors
\definecolor{myblue}{RGB}{80,80,160}
\definecolor{mygreen}{RGB}{80,160,80}
\definecolor{darkblue}{rgb}{0,0,.6}
\definecolor{darkred}{rgb}{.6,0,0}
\definecolor{darkgreen}{rgb}{0,.5,0}
\definecolor{red}{rgb}{.98,0,0}
\definecolor{shellbackgroundcolor}{rgb}{1,1,1}
\definecolor{shellfontcolor}{rgb}{0,0,0}
\definecolor{shadethmcolor}{rgb}{1,1,1}
\definecolor{bg}{rgb}{0.975,0.98,1}
\definecolor{shaderulecolor}{rgb}{0.40,0.45,0.40}%
\definecolor{mywhite}{rgb}{1,1,1}
\definecolor{myblack}{rgb}{0,0,0}

%%c++ newenvironment
\lstset{%
  language=C++,
  basicstyle= \fontsize{9}{1} \ttfamily,
  commentstyle=\itshape\color{darkgreen},
  keywordstyle=\bfseries\color{darkblue},
  stringstyle=\color{darkred},
  showspaces=false,
  showtabs=false,
  columns=fixed,
  %numbers=left,
  tabsize=3,
  %frame=trBL,
  backgroundcolor=\color{white},
  rulecolor=\color{shaderulecolor},
  %frame=single ,
  numberstyle=\tiny,
  breaklines=true,
  showstringspaces=false,
  xleftmargin=0cm,
  nolol=true,
  captionpos=b,
  morekeywords={Vector,VectorVector,EE,DglE1} }

\lstnewenvironment{cppcode}[1][]%
{
%\begin{center}
\minipage{\textwidth}
\renewcommand\lstlistingname{C++ Code Snipped}%
\renewcommand\lstlistlistingname{c++ Code Snippeds}%
\lstset{%
  language=C++,
  basicstyle= \fontsize{9}{9} \ttfamily,
  commentstyle=\bfseries\itshape\color{darkgreen},
  keywordstyle=\bfseries\color{darkblue},
  stringstyle=\color{darkred},
  showspaces=false,
  showtabs=false,
  columns=fixed,
  %numbers=left,
  tabsize=3,
  caption=#1,
  frame=tb,
  backgroundcolor=\color{bg},
  rulecolor=\color{black},
  %frame=single ,
  %numberstyle=\tiny,
  breaklines=true,
  showstringspaces=false,
  xleftmargin=0cm,
  nolol=true,
  captionpos=b,
  morekeywords={VectorVector,DglE1,EE,Model,Solver} }
}
{
\endminipage
%\end{center}
}

\newcommand{\parspace}{ $\;$\\  \\ }

\newcommand{\code}[1]{\lstinline| #1 |}

\begin{document}
	%\title{Strukturen großer Netzwerke}
	%\author{Kathrin Ronellenfitsch}
	%\maketitle

	\begin{center}
		\huge % Schriftgröße einstellen
		\bfseries % Fettdruck einschalten
		\sffamily % Serifenlose Schrift
		Numerik Blatt 1\\[1em]
		\normalsize
		Kathrin Ronellenfitsch, Thorsten Beier, Christopher Pommrenke
	\end{center}

	
	\section*{Aufgabe 1}

    		\subsection*{1.1}

		\begin{align*}
			v'''''(x) - a(x)u'(x) &= f(x),	\\
			u''(x) - b(x)v(x) &= g(x)
		\end{align*}

		
		 \subsection*{1.2}

		\begin{align*}
			v'''''(x) - a(x)u''(x) &= f(x),	\\
			u''(x) - b(x)v(x) &= g(x)
		\end{align*}



	\section*{Aufgabe 2}

  		\subsection*{2.1}

		\begin{equation*}
			u'(t) = u(t)^2,\quad t \geq 0, \ u(0) = 1
		\end{equation*}
		
		\begin{equation*}
			f(t,u) = u =  u(t)^2
		\end{equation*}

		{\bf Eindeutigkeit:}
		\begin{equation*}
			||f(t,u) - f(t,v)|| =||u^2 - v^2|| = ||(u + v) (u - v)|| = ||u + v|| ||u - v|| \leq L(t) ||u - v||
		\end{equation*}
		mit $L(t) = \max\limits_{u,v ,\in D} ||u + v||  \Rightarrow$ die Funktion genuegt der lokalen Lipschitzbedingung $ \Rightarrow $ die Loesung der AWA ist eindeutig. \newline \newline

		{\bf Globalitaet:}
		\begin{equation*}
			u'(t) = u(t)^2 \Leftrightarrow \frac{du}{dt} = u^2 \Rightarrow \int \frac{1}{u^2}du = \int 1 dt \Rightarrow -u^{-1} = t+C \Rightarrow -1 = (t+C) \cdot u \Rightarrow u = \frac{-1}{C+t}
		\end{equation*}
		
		Da $u(0) = 1$ gilt, folgt $C= -1$ und somit ist die Loesung der DGL $u(t) = \frac{1}{1-t}$\\
		Fuer $t = 1$ ist $u(t)$ nicht definiert und damit ist die Loesung nicht global.


 		\subsection*{2.2}

		\begin{equation*}
			u'(t) = -u(t)^2,\quad t \geq 0, \ u(0) = 1
		\end{equation*}

		\begin{equation*}
			f(t,u) = - u = - u(t)^2
		\end{equation*}

		{\bf Eindeutigkeit:}
		\begin{equation*}
			||f(t,u) - f(t,v)|| =||-u^2 + v^2|| = ||(v + u) (v - u)|| = ||v + u|| ||v - u|| = ||v + u|| ||-u - (-v)|| \leq L(t) || -u - (-v)|| 
		\end{equation*}
		mit $L(t) = \max\limits_{u,v ,\in D} ||u + v||  \Rightarrow$ die Funktion genuegt der lokalen Lipschitzbedingung $\Rightarrow$ die Loesung der AWA ist eindeutig. \newline \newline

		{\bf Globalitaet:}
		\begin{equation*}
			u'(t) =- u(t)^2 \Leftrightarrow \frac{du}{dt} = -u^2 \Rightarrow \int \frac{1}{-u^2}du = \int 1 dt \Rightarrow u^{-1} = t+C \Rightarrow 1 = (t+C) \cdot u \Rightarrow u = \frac{1}{C+t}
		\end{equation*}
		
		Da $u(0) = 1$ gilt, folgt $C= 1$ und somit ist die Loesung der DGL $u(t) = \frac{1}{1+t}$\\
		Es gilt: 
		\begin{equation*}
			\left| \left| u(t) \right| \right| = \left| \left| \frac{1}{1+t} \right| \right| = \frac{1}{1+t} \leq 1 \quad \text {für } t \geq 0
		\end{equation*}

		Damit folgt mit Korollar 2.4 über die globale Existenz, dass sich $u$ zu einer Lösung auf ganz $\mathbb{R}$ fortsetzen lässt.



 		\subsection*{2.3}

		\begin{equation*}
			u'(t) = u(t)^{1/2},\quad t \geq 0, \ u(0) = 1
		\end{equation*}

		\begin{equation*}
			f(t,u) = u =  u(t)^{1/2}
		\end{equation*}

		{\bf Eindeutigkeit:}
		\begin{equation*}
			||f(t,u) - f(t,v)|| \leq L(t) ||u - v||  \Leftrightarrow \frac{||f(t,u) - f(t,v)||}{ ||u - v|| } \leq L(t)
		\end{equation*}
		
		Aber 
		\begin{equation*}
			 \frac{||f(t,u) - f(t,0)||}{ ||u - 0|| } = \left | \left | \frac{u^{1/2}}{u} \right | \right | =  \left | \left |  \frac{1}{\sqrt{u}} \right | \right | \to \infty \text { fuer } u \to 0 \quad \Rightarrow
		\end{equation*}

		\begin{equation*}
		\nexists L(t) \text { mit } \frac{||f(t,u) - f(t,v)||}{ ||u - v|| } \leq L(t)  \Leftrightarrow ||f(t,u) - f(t,v)|| \leq L(t) ||u - v|| \Rightarrow
		\end{equation*}

		die Funktion genuegt keiner Lipschitzbedingung.\newline \newline
		Die Loesung der Gleichung ist nicht eindeutig, da:

		\begin{equation*}
			u'(t) = u(t)^{1/2} \Leftrightarrow \frac{du}{dt} = u^{1/2} \Rightarrow \int \frac{1}{u^{1/2}}du = \int 1 dt \Rightarrow 2u^{1/2} = t+C \Rightarrow 4u = (t+C)^2 \Rightarrow u = \frac{(t+C)^2}{4}
		\end{equation*}

		Da $u(0) = 1$ gilt, folgt $\frac{C^2}{4} = 1$ und somit $C=\pm 2$.\\
		Also ist sowohl $u(t) = \frac{(t+2)^2}{4}$ als auch  $u(t) = \frac{(t-2)^2}{4}$ eine Loesung der DGL.


 		\subsection*{2.4}

		\begin{equation*}
			u'(t) = cos(u(t)) - 2u(t),\quad t \geq 0, \ u(0) = 1
		\end{equation*}

		\begin{equation*}
			 \frac{||f(t,u) - f(t,0)||}{ ||u - 0|| } = \left | \left | \frac{\cos(u) - 2u - \cos(0) - 2 \cdot 0}{u} \right| \right| =  \left | \left | \frac{\cos(u)}{u} - 2 - \frac{1}{u} \right| \right|
		\end{equation*}

    \section*{Aufgabe 3}
    
    \section*{Aufgabe 4}

    Verwendete Headder:
        
\begin{cppcode}
#include <iostream>

#include "hdnum.hh"
#include "initial_value_problem.h"
#include "expliciteuler.hh"          //from examplecode of hdnum
    \end{cppcode}
    
    Hilfsfunktion um bestmögliche Annäherung an einen vorgegebenen Zeitschritt
    zu bestimmen:
    
    \begin{cppcode}
// y - eps < x < y + eps ?
bool inRange(const double x, const double y, const double eps) {
    if(x > y - eps) {
        if (x < y + eps) {
            return true;
        } else {
            return false;
        }
    } else {
        return false;
    }
}
    \end{cppcode}
    
    Hilfsfunktion um die Konvergenzordnung zu berechnen:
    
    \begin{cppcode}
template <class T>
T computeConvergenceOrder(const T x1, const T x2, const T xExact) {
  const T error1 = x1 - xExact;
  const T error2 = x2 - xExact;
  return log(fabs(error1 / error2)) / log(2.0);
}
    \end{cppcode}
    
    Hilfsfunktion um den Durchschnittswert eines Vectors zu berechnen:
    
    \begin{cppcode}
template <class VECTOR>
typename VECTOR::value_type computeAverage(const VECTOR& vec) {
  typename VECTOR::value_type average = 0.0;
  for(size_t i = 0; i < vec.size(); i++) {
    average += vec.at(i);
  }
  average /= vec.size();
  return average;
}
    \end{cppcode}
    
    main():
    
    \begin{cppcode}
int main() {
    typedef double Number;                  // define a number type

    const Number t0             = -3.0;     // initial time
          Number tStep          = 0.00001;  // delta t
    const Number tIntermediate  = 1.0;      // state at this time will be printed on console
    const Number uIntermediate  = 1.0 / (1.0 + (100.0 * tIntermediate * tIntermediate)); // exact state at tIntermediate
    const Number tMax           = 3.0;       // end time
    const Number u0             = 1.0/901.0; // initial state
    const Number lambda         = -200.0;    // factor for the model

    const size_t iStart         = 5;
    const size_t iEnd           = 10;

    hdnum::Vector<Number> statesIntermediate;     // store intermediate state values
    for(size_t i = iStart; i <= iEnd; i++) {
      tStep = pow(2.0, -static_cast<double>(i));
      typedef InitialValueProblem<Number> Model; // Model type
      Model model(lambda, u0, t0);               // instantiate model

      typedef ExplicitEuler<Model> Solver;       // Solver type
      Solver solver(model);                      // instantiate solver
      solver.set_dt(tStep);                      // set initial time step

      hdnum::Vector<Number> times;               // store time values here
      hdnum::Vector<hdnum::Vector<Number> > states; // store states here
      times.push_back(solver.get_time());        // initial time
      states.push_back(solver.get_state());      // initial state

      while (solver.get_time() <= tMax)          // the time loop
      {
        solver.step();                           // advance model by one
        time step times.push_back(solver.get_time()); // save time
        states.push_back(solver.get_state());         // and state
        if(inRange(tIntermediate, solver.get_time(), tStep/2.0)) {  // print state at intermediate time
          statesIntermediate.push_back(solver.get_state().at(0)); 
        }
      }
    }

    hdnum::Vector<Number> convergenceOrders;     // store computed convergence orders
    for(size_t i = 0; i < iEnd - iStart; i++) {
      convergenceOrders.push_back(computeConvergenceOrder(statesIntermediate.at(i), statesIntermediate.at(i + 1), uIntermediate));
      std::cout << "convergence order for h = " << pow(2.0, -static_cast<double>(i + iStart)) << " : " << convergenceOrders.back() << std::endl;
    }

    Number averageConvergenceOrder = computeAverage(convergenceOrders);
    std::cout << "average convergence order: " << averageConvergenceOrder << std::endl;
    return 0;
}
    \end{cppcode}
    
    \subsection*{Berechnete Werte:}
    
    \begin{tabular}[htbp]{c|c}
    h & Konvergenzordnung \\
    \hline
    $2^{-5}$ & $0.697208$ \\
    $2^{-6}$ & $0.790967$ \\
    $2^{-7}$ & $0.861423$ \\
    $2^{-8}$ & $0.911732$ \\
    $2^{-9}$ & $0.946279$ \\
    \hline
    \hline
    $\varnothing$ & 0.841522

    \end{tabular}
\end{document}
